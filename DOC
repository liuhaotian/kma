P2FL:	Each page has a header, this header has some information about this page. It first has a point that pointing to the kpage_t ptr, so that we can free it as we want. Then, there is a int numalloc, this keeps a log of the page's allocating, record the number. Also there is a free list for power of two, each list pointing to its buffer. And for the buffers in the page, they have a header point to the free list it belonging to. And following the header, it is the data. If it is free, the header points to the next free buffer. Particularly, the first page we call it mainpage, has an additional variable named numpages, it indicates how many pages we have already used. When dealing with the request, we first check the free list, so that we can make full use of the free buffer not getting a new page. If there is no buffer available, we try to search each page's end, checking if there is some enough space we can use. If not, we come to the final option, that is we get a new page. For this implementation, as we should keep it sequential, we don't free the page when all the pages is not empty. And also, whenever we free a buffer, we just add it to the very beginning of the free list, this make it less efficient.

BUD:	We still use the power of two, but this time is different. At the very beginning, we take a whole page to store all the information we need. The first page called mainpage. If it is full, we just alloc a new one and add it to the previous one's end. The mainpage keep a track of the number of alloc for the entire program, and also has a numpages takes account for the used pages which is under control of the mainpage. The control means, in the mainpage, there is a structure array that storing each page's kpage_t item and the address and also the numalloc of that page and a bitmap which we will use for finding buddy. For each data page, there is no header. So we can store up to 8192bytes. When a request coming, the kma_bud first check the free list which is almost the same as p2fl. If hit, then alloc, but there is an addition action that we mark the bitmap to indicate that the current block we are talking about is being used. The bitmap has 64 unsigned char, so it has 512bits which, in our implementation every one bit cover 16bytes' block, can cover the whole 8192bytes. If free list miss, we try the large free list, if we have, we divide it to two same size block, and keep doing this dividing until we got the right size block we need. If all the ways don't work, we finally get a new page, and divide it in the same way for the large block to the right size block. Once we divide blocks, there must also be a combine method. And yes we have one, it can first look up the bitmap, and find its buddy, and try to combine both of them to a large one. And doing the same thing till we reach the largest 8192 one.

LZBUD:	Totally base on the buddy system. We only change a few things. First, we keep a record of slack for each free list. The slack follows the Algorithm talked in the hand-out. Also we carefully maintain the slack when dividing block into two small ones. When dealing with the combination, we don't care about the slack, because we are dealing with the globally free blocks, and slack = N-2L-G, it doesn't make any sense to slack. In addition, we improve the function that adding the free buffer to the free list that we add it in the order of the address of the buffer. The most difficult party for this algorithm I think is that when slack is Zero, we need to free another buffer and try to combine it as possible. It make it too conflicted, that, they can be in the same page, and in the following page or in the two pages which are not near each other. This has a huge impact for my free page function. So we separately keep track of this two pages, can try to free it, but not free it twice. Then, change the method to free all pages that we emulate all the pages from the end to the beginning and check the numalloc so that we can free it.

MCK2:	It mainly keep one page for a fix size. When finishing all the algorithm above, this one is straightforward. We still use the idea for p2fl, that each page has its own header at the very beginning of that page. When we initial the page, we divide the entire page to the fix size buffers and set each buffer point to the following one. Then add the last one and the first one, and then set the first one point to the following one. So that all the buffer are in the link. As to keep it sequential, we cannot free a page that in the middle of the page queue, so we mark it empty, so that the next time we try to get a page, we can use it for a different size. To point out that, when we set a page to empty, we set the first buffer within the page point the one that last buffer is pointing to, and then unlink the first buffer, so that all the buffers are unlink, this is promised by the ordering of address when we add the free buffer into the free list.

FUN:	This is for competition. It come from converting the bud to lzbud, that I improve the function that adding free buffer to a free list in the order of address. Also, we make a improvement that when we free a 8192bytes block, there is no need to empty the bit map, so just free the page. As the 5.trace has a lot of request for more than 4096bytes-size block, this indeed improves.